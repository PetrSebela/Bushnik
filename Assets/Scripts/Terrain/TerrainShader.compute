#pragma kernel TerrainMesh
#pragma kernel PreviewHeightmap
#pragma kernel SamplePoints

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise2D.hlsl"

#define THREAD_GROUP_SIZE 32u

// === Common terrain settings ===

// Size of the generated terrain
float TerrainSize;

float Gaussian(float t, float center = 0.5f, float falloff = 0.1f)
{
    return exp(-pow(t - center, 2) / pow(falloff, 2));
}

float Sigmoid(float t, float center, float steepness)
{
    t -= center;
    t *= steepness;
    return 1 / (1 + exp(-t));
}

// Simplex noise with values in range (0, 1)
float NormalizedNoise(float2 position)
{
    return (1 + SimplexNoise(position)) / 2;
}

// Inspired by https://thebookofshaders.com/13/
float CreaseNoise(float2 position)
{
    return 1 - abs(SimplexNoise(position));
}

// Returns sample of falloff map
float FalloffMap(float2 position)
{
    // Squircle equation 
    float p = 3;
    return abs(pow(abs(position.x) / (TerrainSize / 2), p)) + abs(pow(abs(position.y) / (TerrainSize / 2), p));
}

// Implementation of FBM with 
float GetTerrainHeight(float2 position)
{
    int sample_count = 20;

    float sample = 0;
    float amplitude_sum = 0;

    float frequency = 0.0001f;
    float amplitude = 1;

    for (int i = 0; i < sample_count; ++i)
    {
        // TODO: parametrize 
        float2 warp_offset = float2(
            NormalizedNoise(position * 0.001 + float2(100,0)),
            NormalizedNoise(position * 0.001 + float2(0,100))
        ) * 275;
        
        // Avoid large seed values because of float resolution issues
        float2 seed = float2(TerrainSize, TerrainSize);
        
        float2 sample_position = seed + position + warp_offset;
        float current = 0;
        current += CreaseNoise(sample_position * frequency) * amplitude; 
        current += NormalizedNoise(sample_position * frequency) * amplitude;
        
        current /= 1.5;
        sample += current;
        
        frequency *= 1.35f;
        amplitude_sum += amplitude;
        amplitude *= 0.65f;
    }
    
    sample /= amplitude_sum;
    sample = pow(sample, 3);
    sample -= FalloffMap(position);
    return sample;
}

float3 GetTerrainNormal(float2 position, float delta)
{
    float right = GetTerrainHeight(position + float2(1, 0) * delta) * 1500;
    float left = GetTerrainHeight(position + float2(-1, 0) * delta) * 1500;
    float front = GetTerrainHeight(position + float2(0, 1) * delta) * 1500;
    float back = GetTerrainHeight(position + float2(0, -1) * delta) * 1500;
    
    float3 normal  = float3(
        (left - right) / (2.0 * delta),
        1.0,
        (back - front) / (2.0 * delta)
    );
    
    return normalize(normal);
}

// === Chunk specific settings ===
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> IndexBuffer;
RWStructuredBuffer<float3> NormalBuffer;
RWStructuredBuffer<float2> DataBuffer;

float ChunkSize;
uint ChunkDepth;
uint MeshResolution;
float3 ChunkPosition;

[numthreads(THREAD_GROUP_SIZE, 1, THREAD_GROUP_SIZE)]
void TerrainMesh(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= MeshResolution || id.z >= MeshResolution)
        return;
    
    float3 chunkPosition = id * ChunkSize / (MeshResolution - 1) - ChunkSize / 2.0f;
    float3 worldPosition = ChunkPosition + chunkPosition;
    float2 flatWorldPosition = float2(worldPosition.x, worldPosition.z);
    
    float local = GetTerrainHeight(flatWorldPosition) * 1500;

    float offset = ChunkSize / (MeshResolution - 1);
    
    chunkPosition.y = local;

    int vertex_index = id.x + id.z * MeshResolution;
    VertexBuffer[vertex_index] = chunkPosition;
    
    NormalBuffer[vertex_index] = float3(0,1,0);
    NormalBuffer[vertex_index] = GetTerrainNormal(flatWorldPosition, ChunkSize / (MeshResolution - 1));

    DataBuffer[vertex_index] = float2(ChunkDepth, 0);

    if (id.x >= MeshResolution - 1 || id.z >= MeshResolution - 1)
    {
        return;
    }

    int triangle_index = (id.x + id.z * (MeshResolution - 1)) * 6;

    if (id.z % 2u == 0 ^ id.x % 2u == 0 )
    {
        IndexBuffer[triangle_index + 0] = vertex_index;
        IndexBuffer[triangle_index + 1] = vertex_index + MeshResolution;
        IndexBuffer[triangle_index + 2] = vertex_index + 1;

        IndexBuffer[triangle_index + 3] = vertex_index + 1;
        IndexBuffer[triangle_index + 4] = vertex_index + MeshResolution;
        IndexBuffer[triangle_index + 5] = vertex_index + 1 + MeshResolution;
    }
    else
    {
        IndexBuffer[triangle_index + 0] = vertex_index;
        IndexBuffer[triangle_index + 1] = vertex_index + 1 + MeshResolution;
        IndexBuffer[triangle_index + 2] = vertex_index + 1;
        
        IndexBuffer[triangle_index + 3] = vertex_index;
        IndexBuffer[triangle_index + 4] = vertex_index + MeshResolution;
        IndexBuffer[triangle_index + 5] = vertex_index + 1 + MeshResolution;
    }
}


// === Heightmap preview section ===
RWTexture2D<float3> HeightmapPreview;
int PreviewSize;

[numthreads(THREAD_GROUP_SIZE, 1, THREAD_GROUP_SIZE)]
void PreviewHeightmap(uint3 id : SV_DispatchThreadID)
{
    float2 normalizedPosition = float2(id.x / (float)PreviewSize, id.z / (float)PreviewSize) - float2(0.5f, 0.5f);
    float2 flatWorldPosition = normalizedPosition * TerrainSize;

    float value = GetTerrainHeight(flatWorldPosition);
    // value = FalloffMap(flatWorldPosition);
    float3 color = float3(value, value, value);
    
    if (value >= 1)
    {
        HeightmapPreview[id.xz] = float3(1, 1 - value, 1 - value);
    }
    else if (value <= 0)
    {
        HeightmapPreview[id.xz] = float3(0.05f, 0.15f, 0.05f);
    }
    else
    {
        if ((value * 500) % 50 <= 3)
        {
            HeightmapPreview[id.xz] = float3(0,1,0);
        }
        else
        {
            HeightmapPreview[id.xz] = color;
        }
    }
}


// === Sample points ===

RWStructuredBuffer<float3> Points;
int PointsSize;

[numthreads(32, 1, 1)]
void SamplePoints(uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= PointsSize)
        return;

    float3 sample = Points[id.x];
    
    float2 worldPosition = float2(sample.x, sample.z);
    
    float3 normal = GetTerrainNormal(worldPosition, 10);
    
    if (dot(normal, float3(0,1,0)) > 0.95f)
    {
        Points[id.x].y = GetTerrainHeight(worldPosition) * 1500;
        return;
    }
    Points[id.x].y = -1;
}
