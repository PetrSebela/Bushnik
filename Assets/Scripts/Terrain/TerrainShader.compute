#pragma kernel TerrainMesh
#pragma kernel PreviewHeightmap

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise2D.hlsl"

#define MESH_RESOLUTION 32


// === Common terrain settings ===
float TerrainSize;

float NormalizedNoise(float2 position)
{
    return (1 + SimplexNoise(position)) / 2;
}

float GetTerrainHeight(float2 position)
{
    
    int sample_count = 20;
    float sample = 0;
    float frequency = 0.0025f;
    float amplitude = 1;
    float amplitude_sum = 0;
    for (int i = 0; i < sample_count; ++i)
    {
        sample += NormalizedNoise((float2(TerrainSize * 1000, TerrainSize * 1000) + position) * frequency) * amplitude;
        frequency *= 1.15f;
        amplitude_sum += amplitude;
        amplitude *= 0.85f;
    }
    sample /= amplitude_sum;
    
    // float noise = 
    float mask = 1 - length(position) / (TerrainSize/2);
    return sample * mask;
}


// === Chunk specific settings ===
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> IndexBuffer;
RWStructuredBuffer<float3> NormalBuffer;
RWStructuredBuffer<float2> DataBuffer;

float ChunkSize;
int ChunkDepth;
float3 ChunkPosition;

[numthreads(MESH_RESOLUTION, 1, MESH_RESOLUTION)]
void TerrainMesh(uint3 id : SV_DispatchThreadID)
{
    float3 chunkPosition = id * ChunkSize / (MESH_RESOLUTION - 1) - ChunkSize / 2.0f;
    float3 worldPosition = ChunkPosition + chunkPosition;
    float2 flatWorldPosition = float2(worldPosition.x, worldPosition.z);
    
    chunkPosition.y = GetTerrainHeight(flatWorldPosition) * 500;

    int vertex_index = id.x + id.z * MESH_RESOLUTION;
    VertexBuffer[vertex_index] = chunkPosition;
    NormalBuffer[vertex_index] = float3(0, 1, 0);
    DataBuffer[vertex_index] = float2(ChunkDepth, 0);

    if (id.x >= MESH_RESOLUTION - 1 || id.z >= MESH_RESOLUTION - 1)
    {
        return;
    }

    int triangle_index = (id.x + id.z * (MESH_RESOLUTION - 1)) * 6;

    IndexBuffer[triangle_index + 0] = vertex_index;
    IndexBuffer[triangle_index + 1] = vertex_index + MESH_RESOLUTION;
    IndexBuffer[triangle_index + 2] = vertex_index + 1;

    IndexBuffer[triangle_index + 3] = vertex_index + 1;
    IndexBuffer[triangle_index + 4] = vertex_index + MESH_RESOLUTION;
    IndexBuffer[triangle_index + 5] = vertex_index + 1 + MESH_RESOLUTION;
}


// === Heightmap preview section ===
RWTexture2D<float3> HeightmapPreview;
int PreviewSize;

[numthreads(MESH_RESOLUTION, 1, MESH_RESOLUTION)]
void PreviewHeightmap(uint3 id : SV_DispatchThreadID)
{
    float2 normalizedPosition = float2(id.x / (float)PreviewSize, id.z / (float)PreviewSize) - float2(0.5f,0.5f);
    float2 flatWorldPosition = normalizedPosition * TerrainSize;
        
    float value = GetTerrainHeight(flatWorldPosition);

    if (value >= 1)
    {
        HeightmapPreview[id.xz] = float3(1, 1 - value, 1 - value);
    }
    else if (value <= 0)
    {
        // HeightmapPreview[id.xz] = float3(abs(value)*0.1f, abs(value)*0.1f, abs(value));
    }
    else
    {
       HeightmapPreview[id.xz] = float3(value, value, value);
    }
}
