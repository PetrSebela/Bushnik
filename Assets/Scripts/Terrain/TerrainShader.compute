// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainMesh

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise2D.hlsl"

#define MESH_RESOLUTION 32

RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> IndexBuffer;
RWStructuredBuffer<float3> NormalBuffer;
RWStructuredBuffer<float2> DataBuffer;

float ChunkSize;
int ChunkDepth;
float3 ChunkPosition;

[numthreads(MESH_RESOLUTION, 1, MESH_RESOLUTION)]
void TerrainMesh(uint3 id : SV_DispatchThreadID)
{
    float3 chunkPosition = id * ChunkSize / (MESH_RESOLUTION - 1) - ChunkSize / 2.0f;
    float3 worldPosition = ChunkPosition + chunkPosition;
    float2 noisePosition = float2(worldPosition.x, worldPosition.z) * 0.005f;


    chunkPosition.y = SimplexNoise(noisePosition) * 10.0f;

    int vertex_index = id.x + id.z * MESH_RESOLUTION;
    VertexBuffer[vertex_index] = chunkPosition;
    NormalBuffer[vertex_index] = float3(0, 1, 0);
    DataBuffer[vertex_index] = float2(ChunkDepth, 0);

    if (id.x >= MESH_RESOLUTION - 1 || id.z >= MESH_RESOLUTION - 1)
    {
        return;
    }

    int triangle_index = (id.x + id.z * (MESH_RESOLUTION - 1)) * 6;

    IndexBuffer[triangle_index + 0] = vertex_index;
    IndexBuffer[triangle_index + 1] = vertex_index + MESH_RESOLUTION;
    IndexBuffer[triangle_index + 2] = vertex_index + 1;

    IndexBuffer[triangle_index + 3] = vertex_index + 1;
    IndexBuffer[triangle_index + 4] = vertex_index + MESH_RESOLUTION;
    IndexBuffer[triangle_index + 5] = vertex_index + 1 + MESH_RESOLUTION;
}
