#pragma kernel TerrainMesh
#pragma kernel PreviewHeightmap
#pragma kernel SamplePoints

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise2D.hlsl"

#define MESH_RESOLUTION 32

// === Common terrain settings ===

// Size of the generated terrain
float TerrainSize;

float Gaussian(float t, float center = 0.5f, float falloff = 0.1f)
{
    return exp(-pow(t - center, 2) / pow(falloff, 2));
}

float Sigmoid(float t, float center, float steepness)
{
    t -= center;
    t *= steepness;
    return 1 / (1 + exp(-t));
}

// Simplex noise with values in range (0, 1)
float NormalizedNoise(float2 position)
{
    return (1 + SimplexNoise(position)) / 2;
}

// Inspired by https://thebookofshaders.com/13/
float CreaseNoise(float2 position)
{
    return 1 - abs(SimplexNoise(position));
}

// Returns sample of falloff map
float FalloffMap(float2 position)
{
    // Squircle equation 
    float p = 3;
    return abs(pow(abs(position.x) / (TerrainSize / 2), p)) + abs(pow(abs(position.y) / (TerrainSize / 2), p));
}

// Implementation of FBM with 
float GetTerrainHeight(float2 position)
{
    int sample_count = 20;

    float sample = 0;
    float amplitude_sum = 0;

    float frequency = 0.0005f;
    float amplitude = 1;

    for (int i = 0; i < sample_count; ++i)
    {
        // TODO: parametrize 
        float2 warp_offset = float2(
            NormalizedNoise(position * 0.001 + float2(100,0)),
            NormalizedNoise(position * 0.001 + float2(0,100))
        ) * 275;
        
        float2 seed = float2(TerrainSize * 1000, TerrainSize * 1000);
        float2 sample_position = seed + position + warp_offset;
        float current = 0;
        current += CreaseNoise(sample_position * frequency) * amplitude; 
        current += NormalizedNoise(sample_position * frequency) * amplitude;
        current /= 1.5;
        sample += current;
        
        frequency *= 1.35f;
        amplitude_sum += amplitude;
        amplitude *= 0.65f;
    }
    
    sample /= amplitude_sum;
    sample *= sample;
    sample -= FalloffMap(position);
    return sample;
}

// === Chunk specific settings ===
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> IndexBuffer;
RWStructuredBuffer<float3> NormalBuffer;
RWStructuredBuffer<float2> DataBuffer;

float ChunkSize;
int ChunkDepth;
float3 ChunkPosition;

[numthreads(MESH_RESOLUTION, 1, MESH_RESOLUTION)]
void TerrainMesh(uint3 id : SV_DispatchThreadID)
{
    float3 chunkPosition = id * ChunkSize / (MESH_RESOLUTION - 1) - ChunkSize / 2.0f;
    float3 worldPosition = ChunkPosition + chunkPosition;
    float2 flatWorldPosition = float2(worldPosition.x, worldPosition.z);
    
    float local = GetTerrainHeight(flatWorldPosition) * 500;

    float offset = ChunkSize / (MESH_RESOLUTION - 1);
    
    chunkPosition.y = local;

    int vertex_index = id.x + id.z * MESH_RESOLUTION;
    VertexBuffer[vertex_index] = chunkPosition;
    
    NormalBuffer[vertex_index] = float3(0,1,0);

    DataBuffer[vertex_index] = float2(ChunkDepth, 0);

    if (id.x >= MESH_RESOLUTION - 1 || id.z >= MESH_RESOLUTION - 1)
    {
        return;
    }

    int triangle_index = (id.x + id.z * (MESH_RESOLUTION - 1)) * 6;

    IndexBuffer[triangle_index + 0] = vertex_index;
    IndexBuffer[triangle_index + 1] = vertex_index + MESH_RESOLUTION;
    IndexBuffer[triangle_index + 2] = vertex_index + 1;

    IndexBuffer[triangle_index + 3] = vertex_index + 1;
    IndexBuffer[triangle_index + 4] = vertex_index + MESH_RESOLUTION;
    IndexBuffer[triangle_index + 5] = vertex_index + 1 + MESH_RESOLUTION;
}


// === Heightmap preview section ===
RWTexture2D<float3> HeightmapPreview;
int PreviewSize;

[numthreads(MESH_RESOLUTION, 1, MESH_RESOLUTION)]
void PreviewHeightmap(uint3 id : SV_DispatchThreadID)
{
    float2 normalizedPosition = float2(id.x / (float)PreviewSize, id.z / (float)PreviewSize) - float2(0.5f, 0.5f);
    float2 flatWorldPosition = normalizedPosition * TerrainSize;

    float value = GetTerrainHeight(flatWorldPosition);
    value = FalloffMap(flatWorldPosition);
    float3 color = float3(value, value, value);
    
    if (value >= 1)
    {
        HeightmapPreview[id.xz] = float3(1, 1 - value, 1 - value);
    }
    else if (value <= 0)
    {
        HeightmapPreview[id.xz] = float3(0.05f, 0.15f, 0.05f);
    }
    else
    {
        if ((value * 500) % 50 <= 3)
        {
            HeightmapPreview[id.xz] = float3(0,1,0);
        }
        else
        {
            HeightmapPreview[id.xz] = color;
        }
    }
}


// === Sample points ===

RWStructuredBuffer<float3> Points;
int PointsSize;

[numthreads(32, 1, 1)]
void SamplePoints(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= PointsSize)
        return;

    float3 sample = Points[id.x];
    
    // float minHeight = 10;
    // float maxHeight = 400;
    float2 flatWorldPosition = float2(sample.x, sample.z);
    float2 worldPosition = float2(sample.x, sample.z);
    
    float height = -1;
    if (CreaseNoise(flatWorldPosition * 0.001f) < 0.5f)
    {
        height = GetTerrainHeight(worldPosition) * 500;
    }
    
    Points[id.x].y = height ;
}
