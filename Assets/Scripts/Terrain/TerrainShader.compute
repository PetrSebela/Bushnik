#pragma kernel TerrainMesh
#pragma kernel PreviewHeightmap
#pragma kernel SamplePoints

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise2D.hlsl"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise2D.hlsl"

#define THREAD_GROUP_SIZE 32u
#define MAX_BIOME_COUNT 32u

struct Runway
{
    float3 approachThreshold;
    float3 departureThreshold;
    float width;
};

struct TerrainMaterialOverride
{
    float height;
    float material;
    float distance;
};

// === Common terrain settings ===

// Size of the generated terrain
float TerrainSize;

// Airstrips
int AirstripBufferSize;
RWStructuredBuffer<Runway> AirstripBuffer;

// === Helper functions ===
float Gaussian(float t, float center = 0.5f, float falloff = 0.1f)
{
    return exp(-pow(t - center, 2) / pow(falloff, 2));
}


// Rewritten from https://easings.net/#easeInOutCubic
float SmoothEase(float t)
{
    if (t < 0.5)
        return 4 * pow(t, 3);
    return 1 - pow(-2 * t + 2, 3) / 2;
}

float Sigmoid(float t, float center, float steepness)
{
    t -= center;
    t *= steepness;
    return 1 / (1 + exp(-t));
}

// Simplex noise with values in range (0, 1)
float NormalizedNoise(float2 position)
{
    return (1 + SimplexNoise(position)) / 2;
}

// Inspired by https://thebookofshaders.com/13/
float CreaseNoise(float2 position)
{
    return 1 - abs(SimplexNoise(position));
}

// Returns sample of falloff map
float FalloffMap(float2 position)
{
    // Squircle equation 
    float p = 3;
    return abs(pow(abs(position.x) / (TerrainSize / 2), p)) + abs(pow(abs(position.y) / (TerrainSize / 2), p));
}

TerrainMaterialOverride ApplyRunways(float2 position, float value)
{
    TerrainMaterialOverride override;
    override.height = value;
    override.material = 0;
    override.distance = 100000; // Arbitrary large enough value
    
    
    for (int airstripIndex = 0; airstripIndex < AirstripBufferSize; airstripIndex++)
    {
        Runway runway = AirstripBuffer[airstripIndex];
        
        float2 flatApproachThreshold = float2(runway.approachThreshold.x, runway.approachThreshold.z);
        float2 flatDepartureThreshold = float2(runway.departureThreshold.x, runway.departureThreshold.z);
        
        float2 direction = flatDepartureThreshold - flatApproachThreshold;
        float2 relative = position - flatApproachThreshold;
        
        float projection = dot(relative, direction) / dot(direction, direction);
        projection = clamp(projection, 0, 1);
        float3 runwayPoint = runway.approachThreshold * (1 - projection) + runway.departureThreshold * projection; 

        
        float d = distance(direction * projection, relative);
        
        if (d + NormalizedNoise(position * 0.05f) * 20 < 50)
            override.material = 1;
        
        if (d < 200)
            override.distance = d;
        
        float fadeProgress = (d - 50) / 500;
        fadeProgress = clamp(fadeProgress, 0, 1);
        fadeProgress = SmoothEase(fadeProgress) * 0.9 + 0.1;
        override.height = runwayPoint.y / 1500 * (1 - fadeProgress) + override.height * fadeProgress;
    }
    
    return override;
}

// Implementation of FBM with 
TerrainMaterialOverride GetTerrainHeight(float2 position)
{
    int sample_count = 20;

    float sample = 0;
    float amplitude_sum = 0;

    float frequency = 0.0001f;
    float amplitude = 1;

    for (int i = 0; i < sample_count; i++)
    {
        // TODO: parametrize 
        float2 warp_offset = float2(
            NormalizedNoise(position * 0.001 + float2(100,0)),
            NormalizedNoise(position * 0.001 + float2(0,100))
        ) * 275;
        
        // Avoid large seed values because of float resolution issues
        float2 seed = float2(TerrainSize, TerrainSize);
        
        float2 sample_position = seed + position + warp_offset;
        float current = 0;
        current += CreaseNoise(sample_position * frequency) * amplitude; 
        current += NormalizedNoise(sample_position * frequency) * amplitude;
        
        current /= 1.5;
        sample += current;
        
        frequency *= 1.35f;
        amplitude_sum += amplitude;
        amplitude *= 0.65f;
    }
    
    
    // Post processing
    sample /= amplitude_sum;
    sample = pow(sample, 3);
    sample -= FalloffMap(position);
    
    return ApplyRunways(position, sample);
}


float3 GetTerrainNormal(float2 position, float delta)
{
    float right = GetTerrainHeight(position + float2(1, 0) * delta).height * 1500;
    float left = GetTerrainHeight(position + float2(-1, 0) * delta).height * 1500;
    float front = GetTerrainHeight(position + float2(0, 1) * delta).height * 1500;
    float back = GetTerrainHeight(position + float2(0, -1) * delta).height * 1500;
    
    float3 normal  = float3(
        (left - right) / (2.0 * delta),
        1.0,
        (back - front) / (2.0 * delta)
    );
    
    return normalize(normal);
}

// === Chunk specific settings ===
RWStructuredBuffer<float3> VertexBuffer;
RWStructuredBuffer<int> IndexBuffer;
RWStructuredBuffer<float3> NormalBuffer;
RWStructuredBuffer<float2> DataBuffer;

float ChunkSize;
float TerrainHeight;
uint ChunkDepth;
uint MeshResolution;
float3 ChunkPosition;

[numthreads(THREAD_GROUP_SIZE, 1, THREAD_GROUP_SIZE)]
void TerrainMesh(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= MeshResolution || id.z >= MeshResolution)
        return;
    
    float3 chunkPosition = id * ChunkSize / (MeshResolution - 1) - ChunkSize / 2.0f;
    float3 worldPosition = ChunkPosition + chunkPosition;
    float2 flatWorldPosition = float2(worldPosition.x, worldPosition.z);
    
    TerrainMaterialOverride sample = GetTerrainHeight(flatWorldPosition);
    chunkPosition.y = sample.height * TerrainHeight;

    int vertex_index = id.x + id.z * MeshResolution;
    VertexBuffer[vertex_index] = chunkPosition;
    
    // Constant distance keeps visuals much more stable
    NormalBuffer[vertex_index] = GetTerrainNormal(flatWorldPosition, 1);
    
    DataBuffer[vertex_index] = float2(ChunkDepth, sample.material);
    
    if (id.x >= MeshResolution - 1 || id.z >= MeshResolution - 1)
        return;
    
    int triangle_index = (id.x + id.z * (MeshResolution - 1)) * 6;

    // Alternate quad diagonals
    if (id.z % 2u == 0 ^ id.x % 2u == 0 )
    {
        IndexBuffer[triangle_index + 0] = vertex_index;
        IndexBuffer[triangle_index + 1] = vertex_index + MeshResolution;
        IndexBuffer[triangle_index + 2] = vertex_index + 1;

        IndexBuffer[triangle_index + 3] = vertex_index + 1;
        IndexBuffer[triangle_index + 4] = vertex_index + MeshResolution;
        IndexBuffer[triangle_index + 5] = vertex_index + 1 + MeshResolution;
    }
    else
    {
        IndexBuffer[triangle_index + 0] = vertex_index;
        IndexBuffer[triangle_index + 1] = vertex_index + 1 + MeshResolution;
        IndexBuffer[triangle_index + 2] = vertex_index + 1;
        
        IndexBuffer[triangle_index + 3] = vertex_index;
        IndexBuffer[triangle_index + 4] = vertex_index + MeshResolution;
        IndexBuffer[triangle_index + 5] = vertex_index + 1 + MeshResolution;
    }
}


// === Heightmap preview section ===
RWTexture2D<float3> HeightmapPreview;
int PreviewSize;

[numthreads(THREAD_GROUP_SIZE, 1, THREAD_GROUP_SIZE)]
void PreviewHeightmap(uint3 id : SV_DispatchThreadID)
{
    float2 normalizedPosition = float2(id.x / (float)PreviewSize, id.z / (float)PreviewSize) - float2(0.5f, 0.5f);
    float2 flatWorldPosition = normalizedPosition * TerrainSize;

    float value = GetTerrainHeight(flatWorldPosition).height;
    float3 color = float3(value, value, value);
    
    if (value >= 1)
        HeightmapPreview[id.xz] = float3(1, 1 - value, 1 - value);
    else if (value <= 0)
        HeightmapPreview[id.xz] = float3(0.05f, 0.15f, 0.05f);
    else
    {
        if ((value * 500) % 50 <= 3)
        {
            HeightmapPreview[id.xz] = float3(0,1,0);
        }
        else
        {
            HeightmapPreview[id.xz] = color;
        }
    }
}

// === Sample points ===
RWStructuredBuffer<float3> Points;
int PointsSize;
float AngleLimit;

[numthreads(32, 1, 1)]
void SamplePoints(uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= PointsSize)
        return;

    float3 sample = Points[id.x];
    
    float2 worldPosition = float2(sample.x, sample.z);

    float3 normal = GetTerrainNormal(worldPosition, 10);
    float angle = degrees(acos(dot(normal, float3(0,1,0))));
    
    if (angle < AngleLimit)
    {
        TerrainMaterialOverride terrain = GetTerrainHeight(worldPosition);
        if (terrain.distance > 150)
        {
            Points[id.x].y = terrain.height * TerrainHeight;
            return;
        }
    }
    
    Points[id.x].y = -1;
}
